import os
from .read_nested_yaml import read_nested_yaml
from .find_project_root import find_project_root

def read_viash_config(target_config_path, project_root_dir=None):
    """
    Process a Viash config file.

    This function will process a Viash config file in the following ways:

    * Upgrade the config from viash < 0.9 to viash >= 0.9 format.
    * Add 'full_name' field to the config, which is the namespace/name of the config.
    * Add 'all_arguments' field to the config, which is a flattened list of all arguments
      in the config, with an additional 'clean_name' field that is the argument name without
      any leading dashes.

    Args:
        target_config_path: Path to a Viash config file in the target directory.
          Example: `target/executable/path/to/.config.vsh.yaml``

        project_root_dir: Path to the root of the Viash project. If not provided,
          it will be determined automatically based on the target config path.

    Returns:
        The processed config as a dictionary.
    """

    if project_root_dir is None:
        project_root_dir = find_project_root(target_config_path)

    # note: if this config was not generated by viash, use `viash config view` first?
    config = read_nested_yaml(target_config_path)

    rel_target_config_path = os.path.relpath(target_config_path, project_root_dir)

    # Upgrade config from viash < 0.9 to viash >= 0.9 format
    if "functionality" in config:
        # Rename 'info' to 'build_info'
        config["build_info"] = config.pop("info")

        # Fix 'build_info' if present
        if config["build_info"]:
            rel_config_dir = os.path.dirname(rel_target_config_path)
            abs_build_dir = config["build_info"]["output"].replace(f"/{rel_config_dir}", "")

            # Get platform types (assuming 'platforms' is a list of dicts)
            platform_types = [platform["type"] for platform in config["platforms"]]

            # Fix 'build_info' fields using 'os.path' functions
            config["build_info"]["config"] = os.path.relpath(
                config["build_info"]["config"], abs_build_dir
            )
            config["build_info"]["output"] = os.path.relpath(
                config["build_info"]["output"], abs_build_dir
            )

            if config["build_info"]["platform"] == "nextflow":
                config["build_info"]["executable"] = os.path.join(
                    config["build_info"]["output"], "main.nf"
                )
                config["build_info"]["runner"] = "nextflow"
                config["build_info"]["engine"] = "docker|native"
            else:
                config["build_info"]["executable"] = os.path.relpath(
                    config["build_info"]["executable"], abs_build_dir
                )
                config["build_info"]["runner"] = "executable"
                config["build_info"]["engine"] = "|".join(
                    [
                        pt
                        for pt in platform_types
                        if pt in ["docker", "native"]
                    ]
                )

        # Move 'functionality' to top level
        config.update(config.pop("functionality"))

        # Handle argument groups
        if "arguments" in config:
            arg_group = {"name": "Arguments", "arguments": config["arguments"]}

            # Check for existing 'Arguments' group
            existing_ix = next(
                (
                    i
                    for i, grp in enumerate(config["argument_groups"])
                    if grp["name"] == "Arguments"
                ),
                None
            )

            if existing_ix is not None:
                # Merge arguments if 'Arguments' group exists
                arg_group["arguments"].extend(
                    config["argument_groups"][existing_ix]["arguments"]
                )
                config["argument_groups"][existing_ix] = arg_group
            else:
                config["argument_groups"].append(arg_group)

    # Add helper fields
    config["full_name"] = (
        f"{config['namespace']}/{config['name']}"
        if config.get("namespace")
        else config["name"]
    )

    # Flatten arguments and add 'clean_name'
    all_arguments = []
    for arg_group in config["argument_groups"]:
        for argument in arg_group["arguments"]:
            argument["clean_name"] = argument["name"].lstrip("-")
            all_arguments.append(argument)
    config["all_arguments"] = all_arguments

    return config
